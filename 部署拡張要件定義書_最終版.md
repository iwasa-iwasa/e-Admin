# 部署拡張要件定義書（最終版）

## 📋 目次

### 1. 確定事項
- [1.1 実装する機能](#11-実装する機能)
- [1.2 実装しない機能](#12-実装しない機能)
- [1.3 開発スケジュール](#13-開発スケジュール)

### 2. データベース設計
- [2.1 新規テーブル](#21-新規テーブル)
- [2.2 変更テーブル](#22-変更テーブル)
- [2.3 インデックス戦略](#23-インデックス戦略)
- [2.4 マイグレーション計画](#24-マイグレーション計画)

### 3. 主要機能の実装
- [3.1 全社カレンダー承認フロー](#31-全社カレンダー承認フロー)
- [3.2 データ共有機能](#32-データ共有機能)
- [3.3 繰り返し予定の動的展開](#33-繰り返し予定の動的展開)
- [3.4 同時編集競合処理](#34-同時編集競合処理)
- [3.5 監査ログ](#35-監査ログ)

### 4. UI/UX設計
- [4.1 共有予定管理UI](#41-共有予定管理ui)
- [4.2 横断検索フィルター](#42-横断検索フィルター)
- [4.3 部署管理者運用フロー](#43-部署管理者運用フロー)

### 5. リスク管理
- [5.1 技術的リスク](#51-技術的リスク)
- [5.2 運用的リスク](#52-運用的リスク)

### 6. バックアップ戦略
- [6.1 バックアップ方式比較](#61-バックアップ方式比較)
- [6.2 推奨構成](#62-推奨構成)

### 7. 先方確認事項
- [7.1 運用面の確認（8項目）](#71-運用面の確認)
- [7.2 技術面の確認（8項目）](#72-技術面の確認)

### 8. 運用詳細
- [8.1 部署異動時の処理](#81-部署異動時の処理)
- [8.2 退職者データ処理](#82-退職者データ処理)
- [8.3 部署統廃合](#83-部署統廃合)

### 9. 追加検討事項
- [9.1 先方への追加質問（8項目）](#9-追加検討事項)

### 10. 権限マトリクス（詳細）
- [10.1 イベントの権限](#イベントカレンダー予定の権限)
- [10.2 共有メモの権限](#共有メモの権限)
- [10.3 アンケートの権限](#アンケートの権限)

### 11. パフォーマンス最適化（詳細）
- [11.1 N+1問題の防止](#n1問題の防止)
- [11.2 キャッシュ戦略](#キャッシュ戦略の実装)
- [11.3 クエリの最適化](#クエリの最適化)

### 12. Observer実装
- [12.1 DepartmentObserver](#departmentobserver)

### 13. 既存データの移行戦略（詳細）
- [13.1 移行コマンドの実装](#移行コマンドの実装)
- [13.2 実行手順](#実行手順)

---

## 1. 確定事項

### 1.1 実装する機能

| 機能 | 方針 | 理由 |
|------|------|------|
| 全社カレンダー投稿 | 承認フロー必須 | 品質管理・統制 |
| データ共有 | 共有方式（同一データ） | 整合性保証 |
| 繰り返し予定 | 動的展開 | DB肥大化防止 |
| 同時編集競合 | 楽観的ロック | データ損失防止 |
| 監査ログ | 共有予定のみ記録 | 最小限の追跡 |
| 部署管理者運用 | 必須設定・自動通知 | 管理不全防止 |
| バックアップ | XServer + AWS S3 | 二重化（年360円） |

### 1.2 実装しない機能

| 機能 | 理由 |
|------|------|
| 複数部署管理者 | 50名規模では不要 |
| 部署階層構造 | 現時点で不要 |
| PWA化 | レスポンシブで十分 |
| 外部カレンダー連携 | 要望なし |
| ユーザートレーニング | 既に説明会実施済み |

### 1.3 開発スケジュール

| フェーズ | 期間 | 内容 |
|---------|------|------|
| フェーズ0 | 事前 | マイグレーション準備・テスト |
| フェーズ1 | 1.5ヶ月 | 基盤整備 |
| フェーズ2 | 2.5ヶ月 | カレンダー拡張 |
| フェーズ3 | 1.5ヶ月 | メモ・アンケート |
| フェーズ4 | 1ヶ月 | 最適化 |
| **合計** | **6.5ヶ月** | |

---

## 2. データベース設計

### 2.1 新規テーブル

#### ① 部署マスタ
```sql
CREATE TABLE departments (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(100) NOT NULL UNIQUE,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_active (is_active)
);
```

#### ② 全社カレンダー承認
```sql
CREATE TABLE company_event_requests (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    event_data JSON NOT NULL,
    requested_by BIGINT NOT NULL,
    requested_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    status ENUM('pending', 'approved', 'rejected') DEFAULT 'pending',
    reviewed_by BIGINT NULL,
    reviewed_at TIMESTAMP NULL,
    review_comment TEXT NULL,
    FOREIGN KEY (requested_by) REFERENCES users(id),
    FOREIGN KEY (reviewed_by) REFERENCES users(id),
    INDEX idx_status (status)
);
```

#### ③ 予定共有
```sql
CREATE TABLE calendar_event_shares (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    calendar_id BIGINT NOT NULL,
    event_id BIGINT NOT NULL,
    shared_by BIGINT NOT NULL,
    shared_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE KEY (calendar_id, event_id),
    FOREIGN KEY (calendar_id) REFERENCES calendars(calendar_id) ON DELETE CASCADE,
    FOREIGN KEY (event_id) REFERENCES events(event_id) ON DELETE CASCADE,
    INDEX idx_calendar (calendar_id),
    INDEX idx_event (event_id)
);
```

#### ④ 監査ログ
```sql
CREATE TABLE audit_logs (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    action VARCHAR(50) NOT NULL,
    user_id BIGINT NOT NULL,
    event_id BIGINT NULL,
    calendar_id BIGINT NULL,
    details JSON NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_action (action),
    INDEX idx_created_at (created_at)
);
```

### 2.2 変更テーブル

```sql
-- users
ALTER TABLE users 
    ADD COLUMN department_id BIGINT NULL,
    ADD COLUMN role_type ENUM('member', 'department_admin', 'company_admin') DEFAULT 'member',
    ADD FOREIGN KEY (department_id) REFERENCES departments(id) ON DELETE SET NULL;

-- calendars
ALTER TABLE calendars
    ADD COLUMN owner_type ENUM('department', 'company') NOT NULL DEFAULT 'company',
    ADD COLUMN owner_id BIGINT NULL,
    ADD FOREIGN KEY (owner_id) REFERENCES departments(id) ON DELETE CASCADE;

-- events
ALTER TABLE events
    ADD COLUMN visibility_type ENUM('public', 'department', 'custom', 'private') DEFAULT 'custom',
    ADD COLUMN owner_department_id BIGINT NULL,
    ADD COLUMN version INT DEFAULT 0,
    ADD FOREIGN KEY (owner_department_id) REFERENCES departments(id) ON DELETE SET NULL;

-- shared_notes
ALTER TABLE shared_notes
    ADD COLUMN visibility_type ENUM('public', 'department', 'custom', 'private') DEFAULT 'custom',
    ADD COLUMN owner_department_id BIGINT NULL,
    ADD COLUMN version INT DEFAULT 0,
    ADD FOREIGN KEY (owner_department_id) REFERENCES departments(id) ON DELETE SET NULL;

-- surveys
ALTER TABLE surveys
    ADD COLUMN visibility_type ENUM('public', 'department', 'custom', 'private') DEFAULT 'custom',
    ADD COLUMN owner_department_id BIGINT NULL,
    ADD COLUMN version INT DEFAULT 0,
    ADD FOREIGN KEY (owner_department_id) REFERENCES departments(id) ON DELETE SET NULL;

-- trash_items
ALTER TABLE trash_items
    ADD COLUMN owner_department_id BIGINT NULL,
    ADD COLUMN visibility_type VARCHAR(20) NULL,
    ADD FOREIGN KEY (owner_department_id) REFERENCES departments(id) ON DELETE SET NULL;
```

### 2.3 インデックス戦略

**インデックスとは**: データベースの「目次」。検索を高速化する。

**効果**: インデックスなし500ms → インデックスあり5ms（100倍高速）

#### 必須インデックス（15個）

```sql
-- 部署関連（3個）
CREATE INDEX idx_users_department ON users(department_id);
CREATE INDEX idx_users_role_type ON users(role_type);
CREATE INDEX idx_departments_active ON departments(is_active);

-- カレンダー関連（5個）
CREATE INDEX idx_calendars_owner ON calendars(owner_type, owner_id);
CREATE INDEX idx_events_visibility_dept ON events(visibility_type, owner_department_id);
CREATE INDEX idx_events_dates ON events(start_date, end_date);
CREATE INDEX idx_events_created_by ON events(created_by);
CREATE INDEX idx_events_calendar ON events(calendar_id);

-- 共有関連（2個）
CREATE INDEX idx_shares_calendar ON calendar_event_shares(calendar_id);
CREATE INDEX idx_shares_event ON calendar_event_shares(event_id);

-- 参加者関連（2個）
CREATE INDEX idx_participants_user ON event_participants(user_id);
CREATE INDEX idx_participants_event ON event_participants(event_id);

-- その他（3個）
CREATE INDEX idx_notes_visibility_dept ON shared_notes(visibility_type, owner_department_id);
CREATE INDEX idx_surveys_visibility_dept ON surveys(visibility_type, owner_department_id);
CREATE INDEX idx_trash_department ON trash_items(owner_department_id);
```

### 2.4 マイグレーション計画

#### 事前準備（本番実施前に必須）

```bash
# 1. 完全バックアップ
mysqldump -u user -p database > backup_$(date +%Y%m%d_%H%M%S).sql

# 2. テスト環境で3回以上検証
php artisan migrate:department-system --env=testing

# 3. 実行時間計測
# 目標: 1-2分以内

# 4. ロールバック手順確認
mysql -u user -p database < backup_20250120_020000.sql
```

#### 本番実行手順

```bash
# 1. メンテナンスモード
php artisan down --message="システムアップグレード中（約5分）"

# 2. マイグレーション実行
php artisan migrate:department-system

# 3. 動作確認
php artisan tinker
>>> User::with('department')->first()
>>> Event::with('calendar')->first()

# 4. メンテナンスモード解除
php artisan up
```

---

## 3. 主要機能の実装

### 3.1 全社カレンダー承認フロー

#### フロー
```
部署管理者が申請 → 全社管理者に通知 → 承認/却下 → 結果通知
```

#### 実装
```php
// 申請
public function requestCompanyEvent(Request $request)
{
    CompanyEventRequest::create([
        'event_data' => json_encode($request->validated()),
        'requested_by' => auth()->id(),
    ]);
    
    Notification::send(
        User::where('role_type', 'company_admin')->get(),
        new CompanyEventRequested()
    );
}

// 承認
public function approve(CompanyEventRequest $request)
{
    Event::create([
        ...json_decode($request->event_data, true),
        'calendar_id' => $this->getCompanyCalendar()->id,
    ]);
    
    $request->update(['status' => 'approved', 'reviewed_by' => auth()->id()]);
}
```

### 3.2 データ共有機能

#### 実装
```php
// 共有
public function shareToCalendar(Event $event, int $calendarId)
{
    CalendarEventShare::create([
        'calendar_id' => $calendarId,
        'event_id' => $event->event_id,
        'shared_by' => auth()->id(),
    ]);
    
    // 監査ログ記録
    AuditLog::create([
        'action' => 'event_shared',
        'event_id' => $event->event_id,
        'calendar_id' => $calendarId,
        'user_id' => auth()->id(),
    ]);
}

// 表示
public function getEventsForCalendar(int $calendarId)
{
    return Event::where('calendar_id', $calendarId)
        ->orWhereHas('shares', fn($q) => $q->where('calendar_id', $calendarId))
        ->get();
}
```

### 3.3 繰り返し予定の動的展開

```php
public function getExpandedEvents(string $start, string $end)
{
    $events = Event::with('recurrence')->get();
    $expanded = [];
    
    foreach ($events as $event) {
        if ($event->recurrence) {
            $expanded = array_merge(
                $expanded,
                $this->expandRecurrence($event, $start, $end)
            );
        } else {
            if ($event->start_date <= $end && $event->end_date >= $start) {
                $expanded[] = $event;
            }
        }
    }
    
    return $expanded;
}
```

### 3.4 同時編集競合処理

```php
public function update(Request $request, Event $event)
{
    if ($event->version !== $request->input('version')) {
        return response()->json([
            'conflict' => true,
            'current_data' => $event->fresh(),
            'your_changes' => $request->validated(),
        ], 409);
    }
    
    $event->update([
        ...$request->validated(),
        'version' => $event->version + 1,
    ]);
}
```

### 3.5 監査ログ

**記録対象（最小限）**:
- ✅ 他部署への予定共有
- ✅ 全社カレンダー承認/却下
- ✅ 強制保存（競合時）

---

## 4. UI/UX設計

### 4.1 共有予定管理UI

```vue
<template>
  <Card>
    <CardHeader>
      <CardTitle class="flex items-center justify-between">
        <span>共有先カレンダー</span>
        <Button size="sm" @click="showShareDialog = true">
          <Plus class="h-4 w-4 mr-2" />
          共有先を追加
        </Button>
      </CardTitle>
    </CardHeader>
    <CardContent>
      <div class="space-y-2">
        <!-- 元のカレンダー -->
        <div class="flex items-center gap-2 p-2 bg-blue-50 rounded">
          <Calendar class="h-4 w-4 text-blue-600" />
          <div class="flex-1">
            <div class="font-medium">{{ event.calendar.name }}</div>
            <div class="text-xs text-gray-500">元のカレンダー</div>
          </div>
          <Badge>編集可能</Badge>
        </div>
        
        <!-- 共有先 -->
        <div v-for="share in event.shares" :key="share.id"
             class="flex items-center gap-2 p-2 border rounded">
          <Share2 class="h-4 w-4 text-gray-400" />
          <div class="flex-1">
            <div class="font-medium">{{ share.calendar.name }}</div>
            <div class="text-xs text-gray-500">
              {{ share.shared_by.name }}が{{ formatDate(share.shared_at) }}に共有
            </div>
          </div>
          <Badge variant="outline">閲覧のみ</Badge>
          <Button variant="ghost" size="sm" @click="unshare(share.id)">
            <X class="h-4 w-4" />
          </Button>
        </div>
      </div>
    </CardContent>
  </Card>
</template>
```

### 4.2 横断検索フィルター

**インデックスを活用した高速検索**

```php
// バックエンド実装
public function search(Request $request)
{
    $query = Event::query();
    
    // 部署フィルター（インデックス使用）
    if ($request->department_id) {
        $query->where('owner_department_id', $request->department_id);
    }
    
    // 公開範囲フィルター（インデックス使用）
    if ($request->visibility_type) {
        $query->where('visibility_type', $request->visibility_type);
    }
    
    // 期間フィルター（インデックス使用）
    if ($request->start_date && $request->end_date) {
        $query->whereBetween('start_date', [$request->start_date, $request->end_date]);
    }
    
    // 作成者フィルター（インデックス使用）
    if ($request->created_by) {
        $query->where('created_by', $request->created_by);
    }
    
    return $query->with(['creator', 'calendar', 'participants'])->get();
}
```

```vue
<template>
  <div class="space-y-4">
    <div class="grid grid-cols-4 gap-4">
      <!-- 部署フィルター -->
      <Select v-model="filters.department_id">
        <SelectTrigger>
          <SelectValue placeholder="部署" />
        </SelectTrigger>
        <SelectContent>
          <SelectItem :value="null">全部署</SelectItem>
          <SelectItem v-for="dept in departments" :key="dept.id" :value="dept.id">
            {{ dept.name }}
          </SelectItem>
        </SelectContent>
      </Select>
      
      <!-- 公開範囲フィルター -->
      <Select v-model="filters.visibility_type">
        <SelectTrigger>
          <SelectValue placeholder="公開範囲" />
        </SelectTrigger>
        <SelectContent>
          <SelectItem :value="null">全て</SelectItem>
          <SelectItem value="public">全社公開</SelectItem>
          <SelectItem value="department">部署限定</SelectItem>
          <SelectItem value="custom">特定メンバー</SelectItem>
          <SelectItem value="private">非公開</SelectItem>
        </SelectContent>
      </Select>
      
      <!-- 期間フィルター -->
      <DateRangePicker v-model="filters.dateRange" />
      
      <!-- 作成者フィルター -->
      <UserSelect v-model="filters.created_by" placeholder="作成者" />
    </div>
    
    <!-- 検索結果 -->
    <div class="space-y-2">
      <EventCard v-for="event in searchResults" :key="event.id" :event="event" />
    </div>
  </div>
</template>
```

### 4.3 部署管理者運用フロー

#### 運用方針（明文化）

```
【部署管理者の必須設定ルール】

1. 部署作成時
   - 部署作成と同時に管理者アカウントを作成
   - 管理者が設定されるまで部署は有効化されない

2. 管理者退職時
   ステップ1: 次期管理者を選定
   ステップ2: 次期管理者を「部署管理者」に昇格
   ステップ3: 退職予定者を「一般メンバー」に降格
   ステップ4: 退職日に退職予定者を無効化

3. 管理者不在の検知
   - 毎月1日に自動チェック
   - 管理者不在の部署があれば全社管理者に通知
```

#### 実装

```php
// 部署作成時のバリデーション
public function store(Request $request)
{
    $validated = $request->validate([
        'name' => 'required|unique:departments',
        'admin_user_id' => 'required|exists:users,id',
    ]);
    
    DB::transaction(function() use ($validated) {
        $department = Department::create(['name' => $validated['name']]);
        
        User::find($validated['admin_user_id'])->update([
            'department_id' => $department->id,
            'role_type' => 'department_admin',
        ]);
    });
}

// 管理者不在チェック（月次バッチ）
public function checkMissingAdmins()
{
    $departmentsWithoutAdmin = Department::where('is_active', true)
        ->whereDoesntHave('users', function($q) {
            $q->where('role_type', 'department_admin')
              ->where('is_active', true);
        })
        ->get();
    
    if ($departmentsWithoutAdmin->isNotEmpty()) {
        Notification::send(
            User::where('role_type', 'company_admin')->get(),
            new MissingDepartmentAdmins($departmentsWithoutAdmin)
        );
    }
}
```

---

## 5. リスク管理

### 5.1 技術的リスク

#### 🔴 データ移行失敗

**リスク**: 既存データ（数百件）の移行時にエラー

**対策**:
- 完全バックアップ（必須）
- テスト環境で3回以上検証
- ロールバック手順準備
- 段階的移行（部署ごと）

#### 🔴 パフォーマンス劣化

**リスク**: 複雑なクエリで表示遅延

**対策**:
- 15個のインデックス追加
- Eager Loading徹底
- キャッシュ戦略（10分間）

#### 🟡 共有機能の複雑性

**リスク**: 共有先での編集権限が不明確

**対策**:
- 明確なUI表示（バッジ・一覧）
- ヘルプテキスト充実

### 5.2 運用的リスク

#### 🔴 部署管理者不在

**リスク**: 部署に管理者が設定されない

**対策**:
- 部署作成時に管理者必須化
- 月次自動チェック
- 全社管理者に通知

#### 🔴 全社カレンダー乱用

**リスク**: 不適切な内容が申請される

**対策**:
- ガイドライン表示（先方確認必須）
- 却下理由テンプレート

---

## 6. バックアップ戦略

### 6.1 バックアップ方式比較

| 方式 | 容量 | 月額 | 年額 | メリット | デメリット |
|------|------|------|------|---------|---------|
| XServer標準 | 無制限 | 無料 | 無料 | 追加費用なし | 7日分のみ |
| AWS S3 | 10GB | 30円 | 360円 | 長期保存可能 | 設定必要 |
| Google Cloud | 10GB | 26円 | 312円 | 安価 | 設定必要 |
| Backblaze B2 | 10GB | 6円 | 72円 | 最安 | 知名度低 |

### 6.2 推奨構成

```
【二重バックアップ体制】

1. XServer標準（無料）
   - 過去7日分を自動保存
   - 短期復旧用

2. AWS S3（月額30円）
   - 過去3ヶ月分を保存
   - 長期保存・災害対策用
   - 毎日深夜2時に自動アップロード

合計コスト: 年間360円
```

---

## 7. 先方確認事項

### 7.1 運用面の確認

| # | 項目 | 確認内容 | 影響範囲 |
|---|------|---------|---------|
| 1 | 部署統廃合の頻度 | 年に何回程度発生するか？ | 自動移行機能の優先度 |
| 2 | 退職者処理タイミング | 退職日当日？事前処理？ | 予定の所有権移譲タイミング |
| 3 | 全社カレンダー承認期限 | 何日以内に承認が必要？ | リマインダー設定 |
| 4 | 共有予定の編集権限 | 共有先でも編集可能？閲覧のみ？ | 権限設計 |
| 5 | 全社カレンダーガイドライン | どのような内容を投稿可能とするか？ | UI表示内容 |
| 6 | 部署管理者の選定基準 | どのような基準で選定するか？ | 運用ルール |
| 7 | 部署異動の頻度 | 年に何回程度発生するか？ | 異動処理の優先度 |
| 8 | 全社カレンダーの運用責任者 | 誰が承認を行うか？ | 通知先の設定 |

### 7.2 技術面の確認

| # | 項目 | 確認内容 | 影響範囲 |
|---|------|---------|---------|
| 1 | 監査ログ保持期間 | 何ヶ月保持するか？ | ストレージ容量 |
| 2 | バックアップ頻度 | 毎日？週1回？ | 復旧可能な範囲 |
| 3 | バックアップ保存先 | XServerのみ？AWS S3も？ | コスト・安全性 |
| 4 | テスト環境の用意 | 本番と同じ環境を用意できるか？ | 移行テストの精度 |
| 5 | メンテナンス時間帯 | いつメンテナンスを実施するか？ | ダウンタイムの影響 |
| 6 | データ移行の実施日 | いつ実施するか？ | スケジュール調整 |
| 7 | ロールバック判断基準 | どの時点でロールバックするか？ | 障害対応 |
| 8 | パフォーマンス目標 | カレンダー表示は何秒以内？ | 最適化の目標値 |

---

## まとめ

### ✅ 確定事項
- 全社カレンダー承認フロー: 実装
- データ共有方式: 実装（共有先一覧UI含む）
- 繰り返し予定動的展開: 実装
- 同時編集競合処理: 実装
- 監査ログ: 共有予定のみ記録
- 部署管理者運用: 必須設定・自動通知
- バックアップ: XServer + AWS S3（年360円）
- 横断検索: インデックス活用

### 📊 開発規模
- 期間: 6.5ヶ月
- 新規テーブル: 4個
- 変更テーブル: 6個
- インデックス: 15個

### 🎯 次のステップ
1. **マイグレーション準備** - テスト環境で検証
2. **先方確認事項への回答** - 16項目
3. **UI/UX詳細設計** - 共有管理・横断検索
4. **実装開始** - フェーズ1から

---

**作成日**: 2025年1月  
**バージョン**: 最終版  
**ステータス**: 先方確認待ち


## 8. 運用詳細

### 8.1 部署異動時の処理

#### 基本方針
1. **異動前の予定**: 元の部署に残す + 所有権を部署管理者に移譲
2. **異動後の予定**: 新しい部署に移動
3. **繰り返し予定**: 元の部署に残す（部署の定例会議などのため）
4. **参加者が本人のみの予定**: ユーザーに確認

#### 処理フロー

```
ユーザーの部署異動
↓
1. 異動日（今日）を基準に予定を分類
   ├─ 過去の予定（end_date < 今日）
   │  └─ 元の部署に残す + 所有権を部署管理者に移譲
   │
   ├─ 未来の予定（start_date >= 今日）
   │  ├─ 繰り返し予定
   │  │  └─ 元の部署に残す（部署の定例会議のため）
   │  │
   │  └─ 単発予定
   │     ├─ 参加者が本人のみ
   │     │  └─ ユーザーに確認ダイアログ表示
   │     │     ├─ 新しい部署に移動
   │     │     └─ 元の部署に残す + 所有権移譲
   │     │
   │     └─ 参加者が複数
   │        └─ 新しい部署に移動
   │
   └─ 進行中の予定（start_date < 今日 < end_date）
      └─ 元の部署に残す
```

#### 実装

```php
// app/Services/UserDepartmentTransferService.php
public function transferDepartment(User $user, int $newDepartmentId): array
{
    $oldDepartmentId = $user->department_id;
    $today = Carbon::today();
    
    DB::beginTransaction();
    
    try {
        // 1. 過去の予定: 元の部署に残す + 所有権を部署管理者に移譲
        $this->transferPastEvents($user, $oldDepartmentId, $today);
        
        // 2. 繰り返し予定: 元の部署に残す
        $this->keepRecurringEvents($user, $oldDepartmentId);
        
        // 3. 未来の単発予定: 参加者をチェック
        $soloEvents = $this->checkSoloEvents($user, $oldDepartmentId, $today);
        
        if ($soloEvents->isNotEmpty()) {
            // 確認が必要な予定がある場合
            DB::rollBack();
            return [
                'requires_confirmation' => true,
                'solo_events' => $soloEvents,
            ];
        }
        
        // 4. 未来の予定（参加者が複数）: 新しい部署に移動
        $this->transferFutureEvents($user, $oldDepartmentId, $newDepartmentId, $today);
        
        // 5. ユーザーの部署を更新
        $user->update(['department_id' => $newDepartmentId]);
        
        DB::commit();
        
        return ['success' => true];
        
    } catch (\Exception $e) {
        DB::rollBack();
        throw $e;
    }
}

private function transferPastEvents(User $user, int $oldDepartmentId, Carbon $today): void
{
    $departmentAdmin = $this->getDepartmentAdmin($oldDepartmentId);
    
    Event::where('created_by', $user->id)
        ->where('owner_department_id', $oldDepartmentId)
        ->where('end_date', '<', $today)
        ->update(['created_by' => $departmentAdmin->id]);
}

private function keepRecurringEvents(User $user, int $oldDepartmentId): void
{
    $departmentAdmin = $this->getDepartmentAdmin($oldDepartmentId);
    
    Event::where('created_by', $user->id)
        ->where('owner_department_id', $oldDepartmentId)
        ->whereHas('recurrence')
        ->update(['created_by' => $departmentAdmin->id]);
}

private function checkSoloEvents(User $user, int $oldDepartmentId, Carbon $today)
{
    return Event::where('created_by', $user->id)
        ->where('owner_department_id', $oldDepartmentId)
        ->where('start_date', '>=', $today)
        ->whereDoesntHave('recurrence')
        ->whereHas('participants', function($q) use ($user) {
            $q->where('user_id', $user->id);
        }, '=', 1)
        ->get();
}
```

#### 確認ダイアログUI

```vue
<Dialog v-model:open="showTransferConfirm">
  <DialogContent class="max-w-2xl">
    <DialogHeader>
      <DialogTitle>部署異動の確認</DialogTitle>
      <DialogDescription>
        以下の予定は参加者があなたのみです。異動後の扱いを選択してください。
      </DialogDescription>
    </DialogHeader>
    
    <div class="space-y-4">
      <div class="max-h-60 overflow-y-auto space-y-2 border rounded-lg p-4">
        <div v-for="event in soloEvents" :key="event.event_id" class="p-3 bg-gray-50 rounded">
          <div class="font-medium">{{ event.title }}</div>
          <div class="text-sm text-gray-500">
            {{ formatDate(event.start_date) }} - {{ formatDate(event.end_date) }}
          </div>
        </div>
      </div>
      
      <RadioGroup v-model="transferOption">
        <div class="space-y-3">
          <div class="flex items-start space-x-3 p-3 border rounded-lg">
            <RadioGroupItem value="transfer" id="transfer" />
            <Label for="transfer" class="flex-1">
              <div class="font-medium">新しい部署に移動</div>
              <div class="text-sm text-gray-500">
                {{ newDepartment.name }}カレンダーに移動し、引き続き編集できます
              </div>
            </Label>
          </div>
          
          <div class="flex items-start space-x-3 p-3 border rounded-lg">
            <RadioGroupItem value="keep" id="keep" />
            <Label for="keep" class="flex-1">
              <div class="font-medium">元の部署に残す</div>
              <div class="text-sm text-gray-500">
                {{ oldDepartment.name }}カレンダーに残し、所有権を部署管理者に移譲します
              </div>
            </Label>
          </div>
        </div>
      </RadioGroup>
    </div>
    
    <DialogFooter>
      <Button variant="outline" @click="showTransferConfirm = false">キャンセル</Button>
      <Button @click="confirmTransfer">確定</Button>
    </DialogFooter>
  </DialogContent>
</Dialog>
```

### 8.2 退職者データ処理

#### 処理内容

**トリガー**: ユーザー無効化時（`is_active = false`に変更）

**自動処理される内容**:

1. **所有権の移譲**
   - 退職者が作成した未来の予定 → 部署管理者に移譲
   - 退職者が作成した共有メモ → 部署管理者に移譲
   - 退職者が作成したアクティブなアンケート → 部署管理者に移譲

2. **参加者からの除外**
   - 未来の予定（`start_date >= 今日`）から自動的に除外
   - 過去の予定は履歴として保持（除外しない）

3. **ログの記録**
   - 無効化の理由
   - 移譲した予定・メモ・アンケートの件数
   - 除外した予定の件数

#### 実装

```php
// app/Services/UserDeactivationService.php
public function deactivateUser(User $user, string $reason): array
{
    $stats = [
        'transferred_events' => 0,
        'transferred_notes' => 0,
        'transferred_surveys' => 0,
        'removed_from_events' => 0,
    ];
    
    DB::transaction(function() use ($user, $reason, &$stats) {
        $today = Carbon::today();
        $departmentAdmin = $this->getDepartmentAdmin($user->department_id);
        
        // 1. 未来の予定の所有権を移譲
        $futureEvents = Event::where('created_by', $user->id)
            ->where('start_date', '>=', $today)
            ->get();
        
        foreach ($futureEvents as $event) {
            $event->update(['created_by' => $departmentAdmin->id]);
            $stats['transferred_events']++;
        }
        
        // 2. 共有メモの所有権を移譲
        $notes = SharedNote::where('author_id', $user->id)
            ->where('is_deleted', false)
            ->get();
        
        foreach ($notes as $note) {
            $note->update(['author_id' => $departmentAdmin->id]);
            $stats['transferred_notes']++;
        }
        
        // 3. アクティブなアンケートの所有権を移譲
        $surveys = Survey::where('created_by', $user->id)
            ->where('is_active', true)
            ->where('is_deleted', false)
            ->get();
        
        foreach ($surveys as $survey) {
            $survey->update(['created_by' => $departmentAdmin->id]);
            $stats['transferred_surveys']++;
        }
        
        // 4. 未来の予定から参加者として除外
        $removedCount = DB::table('event_participants')
            ->where('user_id', $user->id)
            ->whereIn('event_id', function($query) use ($today) {
                $query->select('event_id')
                      ->from('events')
                      ->where('start_date', '>=', $today);
            })
            ->delete();
        
        $stats['removed_from_events'] = $removedCount;
        
        // 5. ユーザーを無効化
        $user->update([
            'is_active' => false,
            'deactivated_at' => now(),
            'reason' => $reason,
        ]);
        
        // 6. ログを記録
        AuditLog::create([
            'action' => 'user_deactivated',
            'user_id' => $user->id,
            'details' => json_encode([
                'reason' => $reason,
                'stats' => $stats,
            ]),
        ]);
    });
    
    return $stats;
}
```

#### UI表示

```vue
<Dialog v-model:open="showDeactivateDialog">
  <DialogContent>
    <DialogHeader>
      <DialogTitle>ユーザーの無効化</DialogTitle>
      <DialogDescription>{{ user.name }}さんを無効化します</DialogDescription>
    </DialogHeader>
    
    <div class="space-y-4">
      <Alert variant="warning">
        <AlertCircle class="h-4 w-4" />
        <AlertTitle>自動処理される内容</AlertTitle>
        <AlertDescription>
          <ul class="list-disc list-inside space-y-1 mt-2">
            <li>作成した未来の予定 → 部署管理者に移譲</li>
            <li>作成した共有メモ → 部署管理者に移譲</li>
            <li>作成したアンケート → 部署管理者に移譲</li>
            <li>参加予定の未来の予定 → 自動的に除外</li>
          </ul>
        </AlertDescription>
      </Alert>
      
      <div class="space-y-2">
        <Label for="reason">無効化の理由</Label>
        <Textarea id="reason" v-model="reason" placeholder="例：退職、休職など" rows="3" />
      </div>
    </div>
    
    <DialogFooter>
      <Button variant="outline" @click="showDeactivateDialog = false">キャンセル</Button>
      <Button variant="destructive" @click="handleDeactivate">無効化</Button>
    </DialogFooter>
  </DialogContent>
</Dialog>
```

### 8.3 部署統廃合

#### 処理内容

**トリガー**: 管理者が部署統合を実行

**自動処理される内容**:

1. **ユーザーの移動** - 統合元の部署のユーザー → 統合先の部署に移動
2. **データの移動** - 予定・メモ・アンケート・ゴミ箱の`owner_department_id` → 統合先に変更
3. **カレンダーの扱い** - 統合元のカレンダーは削除
4. **統合元の部署** - 削除せず無効化（`is_active = false`）
5. **ログの記録** - 統合元と統合先の部署ID、移動したデータ件数

#### 実装

```php
// app/Services/DepartmentMergeService.php
public function mergeDepartments(
    array $sourceDepartmentIds, 
    int $targetDepartmentId,
    string $reason = ''
): array
{
    $stats = [
        'moved_users' => 0,
        'moved_events' => 0,
        'moved_notes' => 0,
        'moved_surveys' => 0,
        'moved_trash_items' => 0,
    ];
    
    DB::transaction(function() use ($sourceDepartmentIds, $targetDepartmentId, $reason, &$stats) {
        
        // 1. ユーザーを移動
        $movedUsers = User::whereIn('department_id', $sourceDepartmentIds)
            ->update(['department_id' => $targetDepartmentId]);
        $stats['moved_users'] = $movedUsers;
        
        // 2. 予定を移動
        $targetCalendar = $this->getTargetCalendar($targetDepartmentId);
        $movedEvents = Event::whereIn('owner_department_id', $sourceDepartmentIds)
            ->update([
                'owner_department_id' => $targetDepartmentId,
                'calendar_id' => $targetCalendar->calendar_id,
            ]);
        $stats['moved_events'] = $movedEvents;
        
        // 3. 共有メモを移動
        $movedNotes = SharedNote::whereIn('owner_department_id', $sourceDepartmentIds)
            ->update(['owner_department_id' => $targetDepartmentId]);
        $stats['moved_notes'] = $movedNotes;
        
        // 4. アンケートを移動
        $movedSurveys = Survey::whereIn('owner_department_id', $sourceDepartmentIds)
            ->update(['owner_department_id' => $targetDepartmentId]);
        $stats['moved_surveys'] = $movedSurveys;
        
        // 5. ゴミ箱アイテムを移動
        $movedTrash = TrashItem::whereIn('owner_department_id', $sourceDepartmentIds)
            ->update(['owner_department_id' => $targetDepartmentId]);
        $stats['moved_trash_items'] = $movedTrash;
        
        // 6. 統合元の部署を無効化
        foreach ($sourceDepartmentIds as $sourceId) {
            $sourceDept = Department::find($sourceId);
            $sourceDept->update(['is_active' => false]);
            
            // 7. 統合元のカレンダーを削除
            Calendar::where('owner_type', 'department')
                ->where('owner_id', $sourceId)
                ->delete();
            
            // 8. ログを記録
            AuditLog::create([
                'action' => 'department_merged',
                'user_id' => auth()->id(),
                'details' => json_encode([
                    'source_department_id' => $sourceId,
                    'source_department_name' => $sourceDept->name,
                    'target_department_id' => $targetDepartmentId,
                    'reason' => $reason,
                    'stats' => $stats,
                ]),
            ]);
        }
    });
    
    return $stats;
}
```

#### UI表示

```vue
<Dialog v-model:open="showMergeDialog">
  <DialogContent class="max-w-2xl">
    <DialogHeader>
      <DialogTitle>部署の統合</DialogTitle>
      <DialogDescription>複数の部署を1つに統合します</DialogDescription>
    </DialogHeader>
    
    <div class="space-y-4">
      <div class="space-y-2">
        <Label>統合元の部署（複数選択可）</Label>
        <MultiSelect v-model="sourceDepartments" :options="availableDepartments" />
      </div>
      
      <div class="space-y-2">
        <Label>統合先の部署</Label>
        <Select v-model="targetDepartment">
          <SelectTrigger><SelectValue placeholder="統合先を選択" /></SelectTrigger>
          <SelectContent>
            <SelectItem v-for="dept in availableDepartments" :key="dept.id" :value="dept.id">
              {{ dept.name }}
            </SelectItem>
          </SelectContent>
        </Select>
      </div>
      
      <div class="space-y-2">
        <Label>統合の理由</Label>
        <Textarea v-model="reason" placeholder="例：組織再編のため" rows="2" />
      </div>
      
      <Alert variant="warning">
        <AlertCircle class="h-4 w-4" />
        <AlertTitle>自動処理される内容</AlertTitle>
        <AlertDescription>
          <ul class="list-disc list-inside space-y-1 mt-2">
            <li>統合元の全ユーザー → 統合先に移動</li>
            <li>統合元の全予定・メモ・アンケート → 統合先に移動</li>
            <li>統合元のカレンダー → 統合先に統合</li>
            <li>統合元の部署 → 無効化（履歴として保持）</li>
          </ul>
        </AlertDescription>
      </Alert>
    </div>
    
    <DialogFooter>
      <Button variant="outline" @click="showMergeDialog = false">キャンセル</Button>
      <Button variant="destructive" @click="handleMerge" :disabled="!canMerge">
        統合を実行
      </Button>
    </DialogFooter>
  </DialogContent>
</Dialog>
```

---

## 9. 追加検討事項

### ⚠️ 要確認（先方への追加質問）

| # | 項目 | 質問内容 | 影響 |
|---|------|---------|------|
| 1 | 部署異動の通知 | 異動時に関係者に通知するか？ | 通知機能の実装 |
| 2 | 退職者の表示 | 退職者を「退職済み」と表示するか？ | UI表示 |
| 3 | 統廃合の頻度 | 年に何回程度発生するか？ | 機能の優先度 |
| 4 | 承認却下の理由 | 却下理由のテンプレートは必要か？ | UI設計 |
| 5 | 監査ログの閲覧権限 | 誰が閲覧できるか？ | 権限設計 |
| 6 | 共有解除の通知 | 共有解除時に通知するか？ | 通知機能 |
| 7 | 繰り返し予定の上限 | 何年先まで展開するか？ | パフォーマンス |
| 8 | 同時編集の通知 | 編集中表示機能は必要か？ | WebSocket実装 |

---

**更新日**: 2025年1月  
**バージョン**: 最終版（完全版）  
**ステータス**: 運用詳細追加完了・先方確認待ち


## 10. 権限マトリクス（詳細）

### イベント（カレンダー予定）の権限

| 操作 | 一般メンバー | 部署管理者 | 全社管理者 |
|------|------------|-----------|-----------| 
| 全社カレンダー閲覧 | ✅ | ✅ | ✅ |
| 全社カレンダー作成 | ❌ | ❌ | ✅ |
| 全社カレンダー編集 | ❌ | ❌ | ✅ |
| 全社カレンダー削除 | ❌ | ❌ | ✅ |
| 自部署カレンダー閲覧 | ✅ | ✅ | ✅ |
| 自部署カレンダー作成 | ✅ | ✅ | ✅ |
| 自部署カレンダー編集 | ✅※1 | ✅※2 | ❌※3 |
| 自部署カレンダー削除 | ✅※1 | ✅※2 | ❌※3 |
| 他部署カレンダー閲覧 | ✅※4 | ✅※4 | ✅ |
| 他部署カレンダー作成 | ❌ | ❌ | ❌ |
| 他部署カレンダー編集 | ✅※5 | ❌ | ❌※3 |
| 他部署カレンダー削除 | ❌ | ❌ | ❌※3 |

**注釈:**
- ※1: 自分が作成した予定、または参加者として登録されている予定のみ
- ※2: 自部署の全ての予定
- ※3: 全社管理者は部署の自律性を尊重し、部署カレンダーは編集不可
- ※4: 公開範囲に応じて閲覧可能
- ※5: 参加者として登録されている場合のみ

### 共有メモの権限

| 操作 | 一般メンバー | 部署管理者 | 全社管理者 |
|------|------------|-----------|-----------| 
| 全社公開メモ閲覧 | ✅ | ✅ | ✅ |
| 全社公開メモ作成 | ✅ | ✅ | ✅ |
| 全社公開メモ編集 | ✅※1 | ✅※1 | ✅ |
| 全社公開メモ削除 | ✅※1 | ✅※1 | ✅ |
| 部署限定メモ閲覧 | ✅※2 | ✅※2 | ✅ |
| 部署限定メモ作成 | ✅ | ✅ | ✅ |
| 部署限定メモ編集 | ✅※1 | ✅※3 | ❌ |
| 部署限定メモ削除 | ✅※1 | ✅※3 | ❌ |

**注釈:**
- ※1: 自分が作成したメモ、または参加者として登録されているメモのみ
- ※2: 同じ部署のメンバーのみ
- ※3: 自部署の全てのメモ

### アンケートの権限

| 操作 | 一般メンバー | 部署管理者 | 全社管理者 |
|------|------------|-----------|-----------| 
| アンケート閲覧 | ✅※1 | ✅※2 | ✅ |
| アンケート作成 | ✅ | ✅ | ✅ |
| アンケート編集 | ✅※3 | ✅※2 | ✅ |
| アンケート削除 | ✅※3 | ✅※2 | ✅ |
| 回答閲覧 | ✅※3 | ✅※2 | ✅ |

**注釈:**
- ※1: 回答対象者として指定されているアンケートのみ
- ※2: 自部署のアンケート全て
- ※3: 自分が作成したアンケートのみ

---

## 11. パフォーマンス最適化（詳細）

### N+1問題の防止

#### 問題の例

```php
// 悪い例: N+1問題が発生
$events = Event::where('visibility_type', 'public')->get();

foreach ($events as $event) {
    echo $event->creator->name;  // N回のクエリ
    echo $event->participants->count();  // N回のクエリ
    echo $event->calendar->calendar_name;  // N回のクエリ
}
// 合計: 1 + N + N + N = 3N + 1 回のクエリ
// 100件のイベントなら301回のクエリ！
```

#### 解決策: Eager Loading

```php
// 良い例: Eager Loadingで最適化
$events = Event::with(['creator', 'participants', 'calendar'])
    ->where('visibility_type', 'public')
    ->get();

foreach ($events as $event) {
    echo $event->creator->name;  // クエリなし（既にロード済み）
    echo $event->participants->count();  // クエリなし
    echo $event->calendar->calendar_name;  // クエリなし
}
// 合計: 4回のクエリのみ（Event + creator + participants + calendar）
// 100件のイベントでも4回のクエリ！
```

**効果**: 301回 → 4回（約75倍高速化）

### キャッシュ戦略の実装

```php
// app/Services/CacheService.php
class CacheService
{
    /**
     * 部署の公開予定をキャッシュ
     */
    public function getDepartmentPublicEvents(int $departmentId, string $start, string $end)
    {
        $cacheKey = "dept_{$departmentId}_public_events_{$start}_{$end}";
        
        return Cache::remember($cacheKey, now()->addMinutes(10), function() use ($departmentId, $start, $end) {
            return Event::with(['creator', 'participants'])
                ->where(function($q) use ($departmentId) {
                    $q->where('visibility_type', 'public')
                      ->orWhere(function($subQ) use ($departmentId) {
                          $subQ->where('visibility_type', 'department')
                               ->where('owner_department_id', $departmentId);
                      });
                })
                ->whereBetween('start_date', [$start, $end])
                ->get();
        });
    }
    
    /**
     * キャッシュをクリア
     */
    public function clearDepartmentCache(int $departmentId)
    {
        Cache::tags(["department_{$departmentId}"])->flush();
    }
}

// イベント作成・更新時にキャッシュをクリア
public function store(StoreEventRequest $request)
{
    $event = $this->eventService->createEvent($request->validated());
    
    // キャッシュクリア
    app(CacheService::class)->clearDepartmentCache($event->owner_department_id);
    
    return redirect()->back();
}
```

### クエリの最適化

```php
// 複雑なクエリを最適化
public function getEventsApi(Request $request)
{
    $user = auth()->user();
    
    // サブクエリを使用して効率化
    $events = Event::with(['creator:id,name', 'participants:id,name', 'calendar:calendar_id,calendar_name'])
        ->where(function($query) use ($user) {
            $query
                ->where('visibility_type', 'public')
                ->orWhere(function($q) use ($user) {
                    $q->where('visibility_type', 'department')
                      ->where('owner_department_id', $user->department_id);
                })
                ->orWhere('created_by', $user->id)
                ->orWhereHas('participants', function($q) use ($user) {
                    $q->where('user_id', $user->id);
                });
        })
        ->whereBetween('start_date', [$request->start, $request->end])
        ->get();
    
    return response()->json($events);
}
```

---

## 12. Observer実装

### DepartmentObserver

```php
// app/Observers/DepartmentObserver.php
namespace App\Observers;

use App\Models\Department;
use App\Models\Calendar;

class DepartmentObserver
{
    /**
     * 部署作成時に自動的にカレンダーを作成
     */
    public function created(Department $department)
    {
        Calendar::create([
            'calendar_name' => $department->name . 'カレンダー',
            'calendar_type' => 'shared',
            'owner_type' => 'department',
            'owner_id' => $department->id,
        ]);
    }
    
    /**
     * 部署名変更時にカレンダー名も更新
     */
    public function updated(Department $department)
    {
        if ($department->isDirty('name')) {
            Calendar::where('owner_type', 'department')
                ->where('owner_id', $department->id)
                ->update([
                    'calendar_name' => $department->name . 'カレンダー'
                ]);
        }
    }
    
    /**
     * 部署削除時にカレンダーも削除
     */
    public function deleting(Department $department)
    {
        // 関連データのチェック
        $hasUsers = $department->users()->exists();
        $hasEvents = Event::where('owner_department_id', $department->id)->exists();
        
        if ($hasUsers || $hasEvents) {
            throw new \Exception('部署にユーザーまたは予定が存在するため削除できません');
        }
        
        // カレンダーを削除
        Calendar::where('owner_type', 'department')
            ->where('owner_id', $department->id)
            ->delete();
    }
}

// app/Providers/EventServiceProvider.php
use App\Models\Department;
use App\Observers\DepartmentObserver;

public function boot()
{
    Department::observe(DepartmentObserver::class);
}
```

---

## 13. 既存データの移行戦略（詳細）

### 移行コマンドの実装

```php
// app/Console/Commands/MigrateToDepartmentSystem.php
namespace App\Console\Commands;

use Illuminate\Console\Command;
use App\Models\Department;
use App\Models\User;
use App\Models\Calendar;
use App\Models\Event;
use App\Models\SharedNote;
use App\Models\Survey;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Artisan;

class MigrateToDepartmentSystem extends Command
{
    protected $signature = 'migrate:department-system';
    protected $description = '部署システムへの移行';
    
    public function handle()
    {
        $this->info('移行を開始します...');
        
        // メンテナンスモードに入る
        Artisan::call('down', [
            '--message' => 'システムアップグレード中（約5分）',
            '--retry' => 60,
        ]);
        
        try {
            DB::transaction(function() {
                $this->migrateEvents();
                $this->migrateSharedNotes();
                $this->migrateSurveys();
            });
            
            $this->info('移行が完了しました！');
        } catch (\Exception $e) {
            $this->error('移行に失敗しました: ' . $e->getMessage());
            throw $e;
        } finally {
            // メンテナンスモード解除
            Artisan::call('up');
        }
    }
    
    private function migrateEvents()
    {
        $somubuDept = Department::where('name', '総務部')->first();
        $somubuCalendar = Calendar::where('owner_type', 'department')
            ->where('owner_id', $somubuDept->id)
            ->first();
        
        Event::whereNull('owner_department_id')
            ->chunkById(100, function($events) use ($somubuDept, $somubuCalendar) {
                foreach ($events as $event) {
                    $creator = User::find($event->created_by);
                    
                    $event->update([
                        'calendar_id' => $somubuCalendar->calendar_id,
                        'owner_department_id' => $creator?->department_id ?? $somubuDept->id,
                        'visibility_type' => $this->determineVisibilityType($event),
                    ]);
                }
            });
        
        $this->info('Events: ' . Event::count() . '件を移行');
    }
    
    private function migrateSharedNotes()
    {
        $somubuDept = Department::where('name', '総務部')->first();
        
        SharedNote::whereNull('owner_department_id')
            ->chunkById(100, function($notes) use ($somubuDept) {
                foreach ($notes as $note) {
                    $author = User::find($note->author_id);
                    
                    $note->update([
                        'owner_department_id' => $author?->department_id ?? $somubuDept->id,
                        'visibility_type' => $this->determineVisibilityType($note),
                    ]);
                }
            });
        
        $this->info('SharedNotes: ' . SharedNote::count() . '件を移行');
    }
    
    private function migrateSurveys()
    {
        $somubuDept = Department::where('name', '総務部')->first();
        
        Survey::whereNull('owner_department_id')
            ->chunkById(100, function($surveys) use ($somubuDept) {
                foreach ($surveys as $survey) {
                    $creator = User::find($survey->created_by);
                    
                    $survey->update([
                        'owner_department_id' => $creator?->department_id ?? $somubuDept->id,
                        'visibility_type' => $this->determineVisibilityType($survey),
                    ]);
                }
            });
        
        $this->info('Surveys: ' . Survey::count() . '件を移行');
    }
    
    /**
     * 現在の実装から visibility_type を推測
     */
    private function determineVisibilityType($model): string
    {
        // 参加者が0人 → public（全員が閲覧可能だった）
        if (!$model->participants()->exists()) {
            return 'public';
        }
        
        // 参加者がいる → custom（特定のメンバーのみ）
        return 'custom';
    }
}
```

### 実行手順

```bash
# 1. 本番データのバックアップ
mysqldump -u user -p database > backup_$(date +%Y%m%d_%H%M%S).sql

# 2. テスト環境で検証（3回以上）
php artisan migrate:department-system --env=testing

# 3. 本番環境で実行
php artisan migrate:department-system

# 4. 動作確認
php artisan tinker
>>> User::with('department')->first()
>>> Event::with('calendar')->first()
>>> Calendar::where('owner_type', 'department')->count()
```

---

**更新日**: 2025年1月  
**バージョン**: 最終版（完全版 v2）  
**ステータス**: 全内容反映完了
